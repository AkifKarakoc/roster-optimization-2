package com.rosteroptimization.service.optimization.model;

import com.rosteroptimization.entity.Staff;
import com.rosteroptimization.entity.Task;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Represents the complete roster plan generated by optimization algorithm
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RosterPlan {

    private String planId;
    private LocalDateTime generatedAt;
    private String algorithmUsed;
    private LocalDate startDate;
    private LocalDate endDate;

    // All assignments in the plan
    private List<Assignment> assignments;

    // Optimization results
    private double fitnessScore;
    private int hardConstraintViolations;
    private int softConstraintViolations;
    private long executionTimeMs;

    // Unassigned items
    private List<Task> unassignedTasks;
    private List<Staff> underutilizedStaff;

    // Statistics
    private Map<String, Object> statistics;

    // Algorithm-specific metadata
    private Map<String, Object> algorithmMetadata;

    /**
     * Get assignments for specific staff member
     */
    public List<Assignment> getAssignmentsForStaff(Staff staff) {
        return assignments.stream()
                .filter(assignment -> assignment.getStaff().getId().equals(staff.getId()))
                .toList();
    }

    /**
     * Get assignments for specific date
     */
    public List<Assignment> getAssignmentsForDate(LocalDate date) {
        return assignments.stream()
                .filter(assignment -> assignment.getDate().equals(date))
                .toList();
    }

    /**
     * Get assignments for specific staff and date
     */
    public List<Assignment> getAssignmentsForStaffAndDate(Staff staff, LocalDate date) {
        return assignments.stream()
                .filter(assignment -> assignment.getStaff().getId().equals(staff.getId())
                        && assignment.getDate().equals(date))
                .toList();
    }

    /**
     * Calculate total working hours for staff member
     */
    public double getTotalWorkingHours(Staff staff) {
        return getAssignmentsForStaff(staff).stream()
                .mapToDouble(Assignment::getDurationHours)
                .sum();
    }

    /**
     * Calculate total working hours for specific date
     */
    public double getTotalWorkingHoursForDate(LocalDate date) {
        return getAssignmentsForDate(date).stream()
                .mapToDouble(Assignment::getDurationHours)
                .sum();
    }

    /**
     * Get task coverage rate (percentage of tasks assigned)
     */
    public double getTaskCoverageRate() {
        if (unassignedTasks == null) return 100.0;

        int totalTasks = assignments.size() + unassignedTasks.size();
        if (totalTasks == 0) return 100.0;

        return (double) assignments.size() / totalTasks * 100.0;
    }

    /**
     * Get staff utilization rate (percentage of staff with assignments)
     */
    public double getStaffUtilizationRate() {
        long staffWithAssignments = assignments.stream()
                .map(assignment -> assignment.getStaff().getId())
                .distinct()
                .count();

        if (underutilizedStaff == null) return 100.0;

        long totalStaff = staffWithAssignments + underutilizedStaff.size();
        if (totalStaff == 0) return 100.0;

        return (double) staffWithAssignments / totalStaff * 100.0;
    }

    /**
     * Check if the plan is feasible (no hard constraint violations)
     */
    public boolean isFeasible() {
        return hardConstraintViolations == 0;
    }

    /**
     * Get summary of working hours per staff
     */
    public Map<Staff, Double> getWorkingHoursSummary() {
        return assignments.stream()
                .collect(Collectors.groupingBy(
                        Assignment::getStaff,
                        Collectors.summingDouble(Assignment::getDurationHours)
                ));
    }

    /**
     * Get count of assignments per day
     */
    public Map<LocalDate, Long> getAssignmentsPerDay() {
        return assignments.stream()
                .collect(Collectors.groupingBy(
                        Assignment::getDate,
                        Collectors.counting()
                ));
    }

    /**
     * Add statistic
     */
    public void addStatistic(String key, Object value) {
        if (statistics == null) {
            statistics = new java.util.HashMap<>();
        }
        statistics.put(key, value);
    }

    /**
     * Add algorithm metadata
     */
    public void addAlgorithmMetadata(String key, Object value) {
        if (algorithmMetadata == null) {
            algorithmMetadata = new java.util.HashMap<>();
        }
        algorithmMetadata.put(key, value);
    }

    @Override
    public String toString() {
        return String.format("RosterPlan{planId='%s', algorithm='%s', assignments=%d, fitness=%.2f, feasible=%s}",
                planId, algorithmUsed, assignments != null ? assignments.size() : 0, fitnessScore, isFeasible());
    }
}